# file opened: src/main.asm
  1   0000              ; this example demonstrates how you can have your souce data eg. bitmap tiles in slot 0 $0000 and also write to L2
  2   0000              ; in the same memory location.
  3   0000
  4   0000              ; em00k 16/07/23
  5   0000
  6   0000
  7   0000
  8   0000                      SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
  9   0000                      DEVICE ZXSPECTRUMNEXT
 10   0000                      CSPECTMAP "L2_on_SLOT01.map"
 11   0000
 12   0000                      include "hardware.inc"                          ; hardware equates
# file opened: src/hardware.inc
  1+  0000              BIT_UP			equ 4	; 16
  2+  0000              BIT_DOWN		equ 5	; 32
  3+  0000              BIT_LEFT		equ 6	; 64
  4+  0000              BIT_RIGHT		equ 7	; 128
  5+  0000
  6+  0000              DIR_NONE		equ %00000000
  7+  0000              DIR_UP			equ %00010000
  8+  0000              DIR_DOWN		equ %00100000
  9+  0000              DIR_LEFT		equ %01000000
 10+  0000              DIR_RIGHT		equ %10000000
 11+  0000
 12+  0000              DIR_UP_I		equ %11101111
 13+  0000              DIR_DOWN_I		equ %11011111
 14+  0000              DIR_LEFT_I		equ %10111111
 15+  0000              DIR_RIGHT_I		equ %01111111
 16+  0000
 17+  0000              ;-----------------------------------------------------------------------------
 18+  0000              ;-- I/O ports - ZX Spectrum classic (48, 128, Timex, Pentagon, ...) ports
 19+  0000
 20+  0000              ULA_P_FE                        equ $FE     ; BORDER + MIC + BEEP + read Keyboard
 21+  0000              TIMEX_P_FF                      equ $FF     ; Timex video control port
 22+  0000
 23+  0000              ZX128_MEMORY_P_7FFD             equ $7FFD   ; ZX Spectrum 128 ports
 24+  0000              ZX128_MEMORY_P_DFFD             equ $DFFD
 25+  0000              ZX128P3_MEMORY_P_1FFD           equ $1FFD
 26+  0000
 27+  0000              AY_REG_P_FFFD                   equ $FFFD
 28+  0000              AY_DATA_P_BFFD                  equ $BFFD
 29+  0000
 30+  0000              Z80_DMA_PORT_DATAGEAR           equ $6B     ; on ZXN the zxnDMA handles this in zxnDMA mode
 31+  0000              Z80_DMA_PORT_MB02               equ $0B     ; on ZXN the zxnDMA handles this in Zilog mode
 32+  0000
 33+  0000              DIVMMC_CONTROL_P_E3             equ $E3
 34+  0000              SPI_CS_P_E7                     equ $E7
 35+  0000              SPI_DATA_P_EB                   equ $EB
 36+  0000
 37+  0000              KEMPSTON_MOUSE_X_P_FBDF         equ $FBDF
 38+  0000              KEMPSTON_MOUSE_Y_P_FFDF         equ $FFDF
 39+  0000              KEMPSTON_MOUSE_B_P_FADF         equ $FADF   ; kempston mouse wheel+buttons
 40+  0000
 41+  0000              KEMPSTON_JOY1_P_1F              equ $1F
 42+  0000              KEMPSTON_JOY2_P_37              equ $37
 43+  0000
 44+  0000              ;-----------------------------------------------------------------------------
 45+  0000              ;-- I/O ports - ZX Spectrum NEXT specific ports
 46+  0000
 47+  0000              TBBLUE_REGISTER_SELECT_P_243B   equ $243B
 48+  0000                  ; -- port $243B = 9275  Read+Write (detection bitmask: %0010_0100_0011_1011)
 49+  0000                  ;   -- selects NextREG mapped at port TBBLUE_REGISTER_ACCESS_P_253B
 50+  0000
 51+  0000              TBBLUE_REGISTER_ACCESS_P_253B   equ $253B
 52+  0000                  ; -- port $253B = 9531  Read?+Write? (detection bitmask: %0010_0101_0011_1011)
 53+  0000                  ;   -- data for selected NextREG (read/write depends on the register selected)
 54+  0000
 55+  0000              ; indexes into DAC_CHANNEL_* def-arrays, depending on the type of DAC you want to use
 56+  0000              DAC_GS_COVOX_INDEX              equ     1
 57+  0000              DAC_PENTAGON_ATM_INDEX          equ     2
 58+  0000              DAC_SPECDRUM_INDEX              equ     3
 59+  0000              DAC_SOUNDRIVE1_INDEX            equ     4
 60+  0000              DAC_SOUNDRIVE2_INDEX            equ     5
 61+  0000              DAC_COVOX_INDEX                 equ     6
 62+  0000              DAC_PROFI_COVOX_INDEX           equ     7
 63+  0000                  ; -- enable 8bit DACs with PERIPHERAL_3_NR_08, use DAC_*_INDEX to access particular set of ports
 64+  0000                  ;DEFARRAY    DAC_CHANNEL_A  @@,  @@, $FB, $DF, $1F, $F1,  @@, $3F
 65+  0000                  ;DEFARRAY    DAC_CHANNEL_B  @@, $B3,  @@,  @@, $0F, $F3, $0F,  @@
 66+  0000                  ;DEFARRAY    DAC_CHANNEL_C  @@, $B3,  @@,  @@, $4F, $F9, $4F,  @@
 67+  0000                  ;DEFARRAY    DAC_CHANNEL_D  @@,  @@, $FB, $DF, $5F, $FB,  @@, $5F
 68+  0000                  ; -- like for example: ld bc,DAC_CHANNEL_B[DAC_PROFI_COVOX_INDEX]
 69+  0000
 70+  0000              I2C_SCL_P_103B                  equ $103B   ; i2c bus port (clock) (write only?)
 71+  0000              I2C_SDA_P_113B                  equ $113B   ; i2c bus port (data) (read+write)
 72+  0000              UART_TX_P_133B                  equ $133B   ; UART tx port (read+write)
 73+  0000              UART_RX_P_143B                  equ $143B   ; UART rx port (read+write)
 74+  0000              UART_CTRL_P_153B                equ $153B   ; UART control port (read+write)
 75+  0000
 76+  0000              ZILOG_DMA_P_0B                  equ $0B
 77+  0000              ZXN_DMA_P_6B                    equ $6B
 78+  0000                  ; -- port $6B = 107 Read+Write (detection bitmask: %xxxx_xxxx_0110_1011)
 79+  0000                  ;   - The zxnDMA is mostly compatible with Zilog DMA chip (Z8410) (at least
 80+  0000                  ;     as far as old ZX apps are concerned), but has many modifications.
 81+  0000                  ;   - core3.1.1 update - Zilog/zxnDMA mode is now selected by port number, not PERIPHERAL_2_NR_06!
 82+  0000                  ;   - core3.0 update - (REMOVED) specific behaviour details can be selected (PERIPHERAL_2_NR_06)
 83+  0000
 84+  0000              LAYER2_ACCESS_P_123B            equ $123B
 85+  0000                  ; -- port $123B = 4667 Read+Write (detection bitmask: %0001_0010_0011_1011)
 86+  0000                  ;   - see ports.txt or wiki for details (has become a bit more complex over time)
 87+  0000
 88+  0000              LAYER2_ACCESS_WRITE_OVER_ROM    equ $01     ; map Layer2 bank into ROM area (0000..3FFF) for WRITE-only (reads as ROM)
 89+  0000              LAYER2_ACCESS_L2_ENABLED        equ $02     ; enable Layer2 (make banks form nextreg $12 visible)
 90+  0000              LAYER2_ACCESS_READ_OVER_ROM     equ $04     ; map Layer2 bank into ROM area (0000..3FFF) for READ-only
 91+  0000              LAYER2_ACCESS_SHADOW_OVER_ROM   equ $08     ; bank selected by bits 6-7 is from "shadow Layer 2" banks range (nextreg $13)
 92+  0000              LAYER2_ACCESS_BANK_OFFSET       equ $10     ; bit 2-0 is bank offset for current active mapping +0..+7 (other bits are reserved, use 0)
 93+  0000              LAYER2_ACCESS_OVER_ROM_BANK_M   equ $C0     ; (mask of) value 0..3 selecting bank mapped for R/W (Nextreg $12 or $13)
 94+  0000              LAYER2_ACCESS_OVER_ROM_BANK_0   equ $00     ; screen lines 0..63    (256x192) or columns 0..63    (320x256) or columns 0..127   (640x256)
 95+  0000              LAYER2_ACCESS_OVER_ROM_BANK_1   equ $40     ; screen lines 64..127  (256x192) or columns 64..127  (320x256) or columns 128..255 (640x256)
 96+  0000              LAYER2_ACCESS_OVER_ROM_BANK_2   equ $80     ; screen lines 128..191 (256x192) or columns 128..191 (320x256) or columns 256..383 (640x256)
 97+  0000              LAYER2_ACCESS_OVER_ROM_48K      equ $C0     ; maps all 0..191 lines into $0000..$BFFF region (256x192) or 2/3 of columns in 320x256/640x256
 98+  0000
 99+  0000              SPRITE_STATUS_SLOT_SELECT_P_303B    equ $303B
100+  0000                  ; -- port $303B = 12347  Read+Write (detection bitmask: %0011_0000_0011_1011)
101+  0000                  ;   -- write:
102+  0000                  ;     - sets both "sprite slot" (0..63) and "pattern slot" (0..63 +128)
103+  0000                  ;     - once the sprite/pattern slots are set, they act independently and
104+  0000                  ;     each port ($xx57 and $xx5B) will auto-increment its own slot index
105+  0000                  ;     (to resync one can write to this port again).
106+  0000                  ;     - the +128 flag will make the pattern upload start at byte 128 of pattern
107+  0000                  ;     slot (second half of slot)
108+  0000                  ;     - The sprite-slot (sprite-attributes) may be optionally interlinked with
109+  0000                  ;     NextReg $34 (feature controlled by NextReg $34)
110+  0000                  ;     - auto-increments of slot position from value 63 are officially
111+  0000                  ;     "undefined behaviour", wrap to 0 is not guaranteed. (only setting slots
112+  0000                  ;     explicitly back to valid 0..63 will make your code future-proof)
113+  0000                  ;   -- read (will also reset both collision and max-sprites flags):
114+  0000                  ;     - bit 1 = maximum sprites per line hit (set when sprite renderer ran
115+  0000                  ;               out of time when preparing next scanline)
116+  0000                  ;     - bit 0 = collision flag (set when any sprites draw non-transparent
117+  0000                  ;               pixel at the same location)
118+  0000                  ;     Both flags contain values for current scanline already at the beginning
119+  0000                  ;     of scanline (sprite engine renders one line ahead into buffer and updates
120+  0000                  ;     flags progressively as it renders the sprites)
121+  0000              SPRITE_STATUS_MAXIMUM_SPRITES   equ $02
122+  0000              SPRITE_STATUS_COLLISION         equ $01
123+  0000              SPRITE_SLOT_SELECT_PATTERN_HALF equ 128     ; add it to 0..63 index to make pattern upload start at second half of pattern
124+  0000
125+  0000              SPRITE_ATTRIBUTE_P_57           equ $57
126+  0000                  ; -- port $xx57 = 87 write-only (detection bitmask: %xxxx_xxxx_0101_0111)
127+  0000                  ;  - writing 4 or 5 bytes long structures to control particular sprite
128+  0000                  ;  - after 4/5 bytes block the sprite slot index is auto-incremented
129+  0000                  ;  - for detailed documentation check official docs or wiki (too long)
130+  0000
131+  0000              SPRITE_PATTERN_P_5B             equ $5B
132+  0000                  ; -- port $xx5B = 91 write-only (detection bitmask: %xxxx_xxxx_0101_1011)
133+  0000                  ;  - each pattern slot is 256 bytes long = one 16x16 pattern of 8-bit pixels
134+  0000                  ;    or two 16x16 patterns of 4-bit pixels.
135+  0000                  ;  - Patterns are uploaded in "English" order (left to right, top to bottom),
136+  0000                  ;    one byte encodes single pixel in 8 bit mode and two pixels in 4 bit
137+  0000                  ;    mode (bits 7-4 are "left" pixel, 3-0 are "right" pixel)
138+  0000                  ;  - pixels are offset (index) into active sprite palette
139+  0000
140+  0000              TURBO_SOUND_CONTROL_P_FFFD      equ $FFFD   ; write with bit 7 = 1 (port shared with AY)
141+  0000
142+  0000              ;-----------------------------------------------------------------------------
143+  0000              ;-- NEXT HW Registers (NextReg)
144+  0000              MACHINE_ID_NR_00                equ $00
145+  0000              NEXT_VERSION_NR_01              equ $01
146+  0000              NEXT_RESET_NR_02                equ $02
147+  0000              MACHINE_TYPE_NR_03              equ $03
148+  0000              ROM_MAPPING_NR_04               equ $04     ;In config mode, allows RAM to be mapped to ROM area.
149+  0000              PERIPHERAL_1_NR_05              equ $05     ;Sets joystick mode, video frequency and Scandoubler.
150+  0000              PERIPHERAL_2_NR_06              equ $06     ;Enables turbo/50Hz/60Hz keys, DivMMC, Multiface and audio (beep/AY)
151+  0000              TURBO_CONTROL_NR_07             equ $07
152+  0000              PERIPHERAL_3_NR_08              equ $08     ;ABC/ACB Stereo, Internal Speaker, SpecDrum, Timex Video Modes, Turbo Sound Next, RAM contention and [un]lock 128k paging.
153+  0000              PERIPHERAL_4_NR_09              equ $09     ;Sets scanlines, AY mono output, Sprite-id lockstep, disables Kempston and divMMC ports.
154+  0000              PERIPHERAL_5_NR_0A              equ $0A     ;Mouse buttons and DPI settings (core 3.1.5)
155+  0000              NEXT_VERSION_MINOR_NR_0E        equ $0E
156+  0000              ANTI_BRICK_NR_10                equ $10
157+  0000              VIDEO_TIMING_NR_11              equ $11
158+  0000              LAYER2_RAM_BANK_NR_12           equ $12     ;bank number where visible Layer 2 video memory begins.
159+  0000              LAYER2_RAM_SHADOW_BANK_NR_13    equ $13     ;bank number for "shadow" write-over-rom mapping
160+  0000              GLOBAL_TRANSPARENCY_NR_14       equ $14     ;Sets the color treated as transparent for ULA/Layer2/LoRes
161+  0000              SPRITE_CONTROL_NR_15            equ $15     ;LoRes mode, Sprites configuration, layers priority
162+  0000                  ; bit 7: enable LoRes mode
163+  0000                  ; bit 6: sprite rendering (1=sprite 0 on top of other, 0=sprite 0 at bottom)
164+  0000                  ; bit 5: If 1, the clipping works even in "over border" mode
165+  0000                  ; 4-2: layers priority: 000=SLU, 001=LSU, 010=SUL, 011=LUS, 100=USL, 101=ULS, 110=S,mix(U+L), 111=S,mix(U+L-5)
166+  0000                  ; bit 1: enable sprites over border, bit 0: show sprites
167+  0000              LAYER2_XOFFSET_NR_16            equ $16
168+  0000              LAYER2_YOFFSET_NR_17            equ $17
169+  0000              CLIP_LAYER2_NR_18               equ $18
170+  0000              CLIP_SPRITE_NR_19               equ $19
171+  0000              CLIP_ULA_LORES_NR_1A            equ $1A
172+  0000              CLIP_TILEMAP_NR_1B              equ $1B
173+  0000              CLIP_WINDOW_CONTROL_NR_1C       equ $1C     ;set to 15 to reset all clip-window indices to 0
174+  0000              VIDEO_LINE_MSB_NR_1E            equ $1E
175+  0000              VIDEO_LINE_LSB_NR_1F            equ $1F
176+  0000              VIDEO_INTERUPT_CONTROL_NR_22    equ $22     ;Controls the timing of raster interrupts and the ULA frame interrupt.
177+  0000              VIDEO_INTERUPT_VALUE_NR_23      equ $23
178+  0000              ULA_XOFFSET_NR_26               equ $26     ;since core 3.0
179+  0000              ULA_YOFFSET_NR_27               equ $27     ;since core 3.0
180+  0000              HIGH_ADRESS_KEYMAP_NR_28        equ $28     ;reads first 8b part of value written to $44 (even unfinished 16b write)
181+  0000              LOW_ADRESS_KEYMAP_NR_29         equ $29
182+  0000              HIGH_DATA_TO_KEYMAP_NR_2A       equ $2A
183+  0000              LOW_DATA_TO_KEYMAP_NR_2B        equ $2B
184+  0000              DAC_B_MIRROR_NR_2C              equ $2C     ;reads as MSB of Pi I2S left side sample, LSB waits at $2D
185+  0000              DAC_AD_MIRROR_NR_2D             equ $2D     ;another alias for $2D, reads LSB of value initiated by $2C or $2E read
186+  0000              SOUNDDRIVE_DF_MIRROR_NR_2D      equ $2D     ;Nextreg port-mirror of port 0xDF
187+  0000              DAC_C_MIRROR_NR_2E              equ $2E     ;reads as MSB of Pi I2S right side sample, LSB waits at $2D
188+  0000              TILEMAP_XOFFSET_MSB_NR_2F       equ $2F
189+  0000              TILEMAP_XOFFSET_LSB_NR_30       equ $30
190+  0000              TILEMAP_YOFFSET_NR_31           equ $31
191+  0000              LORES_XOFFSET_NR_32             equ $32
192+  0000              LORES_YOFFSET_NR_33             equ $33
193+  0000              SPRITE_ATTR_SLOT_SEL_NR_34      equ $34     ;Sprite-attribute slot index for $35-$39/$75-$79 port $57 mirrors
194+  0000              SPRITE_ATTR0_NR_35              equ $35     ;port $57 mirror in nextreg space (accessible to copper)
195+  0000              SPRITE_ATTR1_NR_36              equ $36
196+  0000              SPRITE_ATTR2_NR_37              equ $37
197+  0000              SPRITE_ATTR3_NR_38              equ $38
198+  0000              SPRITE_ATTR4_NR_39              equ $39
199+  0000              PALETTE_INDEX_NR_40             equ $40     ;Chooses a ULANext palette number to configure.
200+  0000              PALETTE_VALUE_NR_41             equ $41     ;Used to upload 8-bit colors to the ULANext palette.
201+  0000              PALETTE_FORMAT_NR_42            equ $42     ;ink-mask for ULANext modes
202+  0000              PALETTE_CONTROL_NR_43           equ $43     ;Enables or disables ULANext interpretation of attribute values and toggles active palette.
203+  0000              PALETTE_VALUE_9BIT_NR_44        equ $44     ;Holds the additional blue color bit for RGB333 color selection.
204+  0000              TRANSPARENCY_FALLBACK_COL_NR_4A equ $4A     ;8-bit colour to be drawn when all layers are transparent
205+  0000              SPRITE_TRANSPARENCY_I_NR_4B     equ $4B     ;index of transparent colour in sprite palette (only bottom 4 bits for 4-bit patterns)
206+  0000              TILEMAP_TRANSPARENCY_I_NR_4C    equ $4C     ;index of transparent colour in tilemap graphics (only bottom 4 bits)
207+  0000              MMU0_0000_NR_50                 equ $50     ;Set a Spectrum RAM page at position 0x0000 to 0x1FFF
208+  0000              MMU1_2000_NR_51                 equ $51     ;Set a Spectrum RAM page at position 0x2000 to 0x3FFF
209+  0000              MMU2_4000_NR_52                 equ $52     ;Set a Spectrum RAM page at position 0x4000 to 0x5FFF
210+  0000              MMU3_6000_NR_53                 equ $53     ;Set a Spectrum RAM page at position 0x6000 to 0x7FFF
211+  0000              MMU4_8000_NR_54                 equ $54     ;Set a Spectrum RAM page at position 0x8000 to 0x9FFF
212+  0000              MMU5_A000_NR_55                 equ $55     ;Set a Spectrum RAM page at position 0xA000 to 0xBFFF
213+  0000              MMU6_C000_NR_56                 equ $56     ;Set a Spectrum RAM page at position 0xC000 to 0xDFFF
214+  0000              MMU7_E000_NR_57                 equ $57     ;Set a Spectrum RAM page at position 0xE000 to 0xFFFF
215+  0000              COPPER_DATA_NR_60               equ $60
216+  0000              COPPER_CONTROL_LO_NR_61         equ $61
217+  0000              COPPER_CONTROL_HI_NR_62         equ $62
218+  0000              COPPER_DATA_16B_NR_63           equ $63     ; same as $60, but waits for full 16b before write
219+  0000              VIDEO_LINE_OFFSET_NR_64         equ $64     ; (core 3.1.5)
220+  0000              ULA_CONTROL_NR_68               equ $68
221+  0000              DISPLAY_CONTROL_NR_69           equ $69
222+  0000              LORES_CONTROL_NR_6A             equ $6A
223+  0000              TILEMAP_CONTROL_NR_6B           equ $6B
224+  0000              TILEMAP_DEFAULT_ATTR_NR_6C      equ $6C
225+  0000              TILEMAP_BASE_ADR_NR_6E          equ $6E     ;Tilemap base address of map
226+  0000              TILEMAP_GFX_ADR_NR_6F           equ $6F     ;Tilemap definitions (graphics of tiles)
227+  0000              LAYER2_CONTROL_NR_70            equ $70
228+  0000              LAYER2_XOFFSET_MSB_NR_71        equ $71     ; for 320x256 and 640x256 L2 modes (core 3.0.6+)
229+  0000              SPRITE_ATTR0_INC_NR_75          equ $75     ;port $57 mirror in nextreg space (accessible to copper) (slot index++)
230+  0000              SPRITE_ATTR1_INC_NR_76          equ $76
231+  0000              SPRITE_ATTR2_INC_NR_77          equ $77
232+  0000              SPRITE_ATTR3_INC_NR_78          equ $78
233+  0000              SPRITE_ATTR4_INC_NR_79          equ $79
234+  0000              USER_STORAGE_0_NR_7F            equ $7F
235+  0000              EXPANSION_BUS_ENABLE_NR_80      equ $80
236+  0000              EXPANSION_BUS_CONTROL_NR_81     equ $81
237+  0000              INTERNAL_PORT_DECODING_0_NR_82  equ $82     ;bits 0-7
238+  0000              INTERNAL_PORT_DECODING_1_NR_83  equ $83     ;bits 8-15
239+  0000              INTERNAL_PORT_DECODING_2_NR_84  equ $84     ;bits 16-23
240+  0000              INTERNAL_PORT_DECODING_3_NR_85  equ $85     ;bits 24-31
241+  0000              EXPANSION_BUS_DECODING_0_NR_86  equ $86     ;bits 0-7 mask
242+  0000              EXPANSION_BUS_DECODING_1_NR_87  equ $87     ;bits 8-15 mask
243+  0000              EXPANSION_BUS_DECODING_2_NR_88  equ $88     ;bits 16-23 mask
244+  0000              EXPANSION_BUS_DECODING_3_NR_89  equ $89     ;bits 24-31 mask
245+  0000              EXPANSION_BUS_PROPAGATE_NR_8A   equ $8A     ;Monitoring internal I/O or adding external keyboard
246+  0000              ALTERNATE_ROM_NR_8C             equ $8C     ;Enable alternate ROM or lock 48k ROM
247+  0000              ZX_MEM_MAPPING_NR_8E            equ $8E     ;shortcut to set classic zx128+3 memory model at one place
248+  0000              PI_GPIO_OUT_ENABLE_0_NR_90      equ $90     ;pins 0-7
249+  0000              PI_GPIO_OUT_ENABLE_1_NR_91      equ $91     ;pins 8-15
250+  0000              PI_GPIO_OUT_ENABLE_2_NR_92      equ $92     ;pins 16-23
251+  0000              PI_GPIO_OUT_ENABLE_3_NR_93      equ $93     ;pins 24-27
252+  0000              PI_GPIO_0_NR_98                 equ $98     ;pins 0-7
253+  0000              PI_GPIO_1_NR_99                 equ $99     ;pins 8-15
254+  0000              PI_GPIO_2_NR_9A                 equ $9A     ;pins 16-23
255+  0000              PI_GPIO_3_NR_9B                 equ $9B     ;pins 24-27
256+  0000              PI_PERIPHERALS_ENABLE_NR_A0     equ $A0
257+  0000              PI_I2S_AUDIO_CONTROL_NR_A2      equ $A2
258+  0000              ;PI_I2S_CLOCK_DIVIDE_NR_A3       equ $A3    ; REMOVED in core 3.1.5 (no more master-mode)
259+  0000              ESP_WIFI_GPIO_OUTPUT_NR_A8      equ $A8
260+  0000              ESP_WIFI_GPIO_NR_A9             equ $A9
261+  0000              EXTENDED_KEYS_0_NR_B0           equ $B0     ;read Next compound keys as standalone keys (outside of zx48 matrix)
262+  0000              EXTENDED_KEYS_1_NR_B1           equ $B1     ;read Next compound keys as standalone keys (outside of zx48 matrix)
263+  0000              ;DIVMMC_TRAP_ENABLE_1_NR_B2      equ $B2    ; NOT IMPLEMENTED in core yet (as of 3.1.4), may happen in future
264+  0000              ;DIVMMC_TRAP_ENABLE_2_NR_B4      equ $B4    ; NOT IMPLEMENTED in core yet (as of 3.1.4), may happen in future
265+  0000              DEBUG_LED_CONTROL_NR_FF         equ $FF     ;Turns debug LEDs on and off on TBBlue implementations that have them.
266+  0000
267+  0000              ;-----------------------------------------------------------------------------
268+  0000              ;-- common memory addresses
269+  0000              MEM_ROM_CHARS_3C00              equ $3C00   ; actual chars start at $3D00 with space
270+  0000              MEM_ZX_SCREEN_4000              equ $4000
271+  0000              MEM_ZX_ATTRIB_5800              equ $5800
272+  0000              MEM_LORES0_4000                 equ $4000
273+  0000              MEM_LORES1_6000                 equ $6000
274+  0000              MEM_TIMEX_SCR0_4000             equ $4000
275+  0000              MEM_TIMEX_SCR1_6000             equ $6000
276+  0000
277+  0000              ;-----------------------------------------------------------------------------
278+  0000              ;-- Copper commands
279+  0000              COPPER_NOOP                     equ %00000000
280+  0000              COPPER_WAIT_H                   equ %10000000
281+  0000              COPPER_HALT_B                   equ $FF   ; 2x $FF = wait for (511,63) = infinite wait
282+  0000
283+  0000              ;-----------------------------------------------------------------------------
284+  0000              ; DMA (Register 6)
285+  0000              DMA_RESET					equ $C3
286+  0000              DMA_RESET_PORT_A_TIMING		equ $C7
287+  0000              DMA_RESET_PORT_B_TIMING		equ $CB
288+  0000              DMA_LOAD					equ $CF
289+  0000              DMA_CONTINUE				equ $D3
290+  0000              DMA_DISABLE_INTERUPTS		equ $AF
291+  0000              DMA_ENABLE_INTERUPTS		equ $AB
292+  0000              DMA_RESET_DISABLE_INTERUPTS	equ $A3
293+  0000              DMA_ENABLE_AFTER_RETI		equ $B7
294+  0000              DMA_READ_STATUS_BYTE		equ $BF
295+  0000              DMA_REINIT_STATUS_BYTE		equ $8B
296+  0000              DMA_START_READ_SEQUENCE		equ $A7
297+  0000              DMA_FORCE_READY				equ $B3
298+  0000              DMA_DISABLE					equ $83
299+  0000              DMA_ENABLE					equ $87
300+  0000              DMA_READ_MASK_FOLLOWS		equ $BB
301+  0000              KEYB        equ $7F10
302+  0000              KEYN        equ $7F08
303+  0000              KEYM        equ $7F04
304+  0000              KEYSYMBOL   equ $7F02
305+  0000              KEYSPACE    equ $7F01
306+  0000              KEYH        equ $BF10
307+  0000              KEYJ        equ $BF08
308+  0000              KEYK        equ $BF04
309+  0000              KEYL        equ $BF02
310+  0000              KEYENTER    equ $BF01
311+  0000              KEYY        equ $DF10
312+  0000              KEYU        equ $DF08
313+  0000              KEYI        equ $DF04
314+  0000              KEYO        equ $DF02
315+  0000              KEYP        equ $DF01
316+  0000              KEY6        equ $EF10
317+  0000              KEY7        equ $EF08
318+  0000              KEY8        equ $EF04
319+  0000              KEY9        equ $EF02
320+  0000              KEY0        equ $EF01
321+  0000              KEY5        equ $F710
322+  0000              KEY4        equ $F708
323+  0000              KEY3        equ $F704
324+  0000              KEY2        equ $F702
325+  0000              KEY1        equ $F701
326+  0000              KEYT        equ $FB10
327+  0000              KEYR        equ $FB08
328+  0000              KEYE        equ $FB04
329+  0000              KEYW        equ $FB02
330+  0000              KEYQ        equ $FB01
331+  0000              KEYG       equ $FD10
332+  0000              KEYF       equ $FD08
333+  0000              KEYD       equ $FD04
334+  0000              KEYS       equ $FD02
335+  0000              KEYA       equ $FD01
336+  0000              KEYV       equ $FE10
337+  0000              KEYC       equ $FE08
338+  0000              KEYX       equ $FE04
339+  0000              KEYZ       equ $FE02
340+  0000              KEYCAPS    equ $FE01
# file closed: src/hardware.inc
 13   0000
 14   0000                      org     $8000
 15   8000
 16   8000              main:
 17   8000 F3                   di
 18   8001                      ; set up hardware
 19   8001 ED 91 07 03          nextreg TURBO_CONTROL_NR_07,3                   ; 28mhz
 20   8005 ED 91 14 00          nextreg GLOBAL_TRANSPARENCY_NR_14,0             ; black
 21   8009 ED 91 4B 00          nextreg SPRITE_TRANSPARENCY_I_NR_4B,0           ; black
 22   800D ED 91 4A 00          nextreg TRANSPARENCY_FALLBACK_COL_NR_4A,$0      ; black
 23   8011 ED 91 15 10          nextreg SPRITE_CONTROL_NR_15,%000'100'00        ; Layer order
 24   8015 ED 91 70 00          nextreg LAYER2_CONTROL_NR_70,%00000000          ; 256x192
 25   8019 ED 91 69 80          nextreg DISPLAY_CONTROL_NR_69,%10000000         ; bit 7 enable L2
 26   801D
 27   801D                      ; we will use a simple map to draw L2 tiles to screen
 28   801D                      ; we will do this by having the source data in the same
 29   801D                      ; slot location as L2 writes
 30   801D
 31   801D AF                   xor     a
 32   801E D3 FE                out     ($fe), a                        ; black border
 33   8020
 34   8020 DD 21 E8 81          ld      ix, testmap                     ; point to test map data
 35   8024 FD 21 18 20          ld      iy, (32*256)+24                 ; width = 32, height = 24
 36   8028
 37   8028 CD 5C 81             call    draw_map                        ; draw the map
 38   802B
 39   802B 18 FE                jr   $                                  ; repeat loop
 40   802D
 41   802D              ;------------------------------------------------------------------------------
 42   802D              ; Stack reservation
 43   802D              STACK_SIZE      equ     100
 44   802D
 45   802D              stack_bottom:
 46   802D 00 00 00...          defs    STACK_SIZE * 2
 47   80F5              stack_top:
 48   80F5 00 00                defw    0
 49   80F7
 50   80F7              ;------------------------------------------------------------------------------
 51   80F7              ; includes
 52   80F7
 53   80F7                      include "utils.asm"
# file opened: src/utils.asm
  1+  80F7
  2+  80F7              ;------------------------------------------------------------------------------
  3+  80F7              ; Utils
  4+  80F7
  5+  80F7              getRegister:
  6+  80F7
  7+  80F7              ; IN A > Register to read
  8+  80F7              ; OUT A < Value of Register
  9+  80F7
 10+  80F7 C5               push    bc                                  ; save BC
 11+  80F8 01 3B 24         ld      bc, TBBLUE_REGISTER_SELECT_P_243B
 12+  80FB ED 79            out     (c), a
 13+  80FD 04               inc     b
 14+  80FE ED 78            in      a, (c)
 15+  8100 C1               pop     bc
 16+  8101 C9               ret
 17+  8102
 18+  8102
 19+  8102              ;----------------------------------------------------------------------------
 20+  8102              ;
 21+  8102              ; Jump index
 22+  8102              ;
 23+  8102              ; In:
 24+  8102              ;	A = Pointer index
 25+  8102              ;    (SP) = Pointer to jump addresses list
 26+  8102              ;
 27+  8102              ;----------------------------------------------------------------------------
 28+  8102
 29+  8102              JumpIndex:
 30+  8102 E1           		    pop	    hl				    ; Pointer to list
 31+  8103
 32+  8103 87                       add     a,  a
 33+  8104 ED 31                    add     hl, a
 34+  8106 5E           		    ld	    e, (hl)
 35+  8107 23           		    inc	    hl
 36+  8108 56           		    ld	    d, (hl)			    ; DE = Address to jump
 37+  8109 EB           		    ex	    de,	hl
 38+  810A E9           		    jp	    (hl)
 39+  810B
 40+  810B
 41+  810B              ; Vsync wait
 42+  810B
 43+  810B              Vsync:
 44+  810B 21 01 00                 ld      hl, 1
 45+  810E              .readline:
 46+  810E 3E 1F        			ld 		a,VIDEO_LINE_LSB_NR_1F
 47+  8110 01 3B 24     			ld 		bc,TBBLUE_REGISTER_SELECT_P_243B
 48+  8113 ED 79        			out 	(c),a
 49+  8115 04           			inc 	b
 50+  8116 ED 78        			in 		a,(c)
 51+  8118 FE C0        			cp 		192				; line to wait for
 52+  811A 20 F2        			jr 		nz,.readline
 53+  811C 2B           			dec 	hl
 54+  811D 7C           			ld 		a,h
 55+  811E B5           			or 		l
 56+  811F 20 ED        			jr 		nz,.readline
 57+  8121 C9                       ret
# file closed: src/utils.asm
 54   8122                      include "layer2.asm"
# file opened: src/layer2.asm
  1+  8122              clsL2:
  2+  8122              	; Clears L2 252x192 with A as colour
  3+  8122              	; IN A > colour
  4+  8122              	; USES : hl, de, bc, a
  5+  8122
  6+  8122 32 3D 81     	ld          (.colour+1), a
  7+  8125 3E 12        	ld          a, $12
  8+  8127 CD F7 80     	call        getRegister
  9+  812A 87           	add         a, a                ; A = start of L2 ram
 10+  812B 06 03        	ld          b, 3                ; 3 blocks to do
 11+  812D              .L2loop:
 12+  812D C5           	push        bc
 13+  812E ED 92 50     	nextreg     MMU0_0000_NR_50, a  ; set 0 - $1fff
 14+  8131 3C           	inc         a
 15+  8132 ED 92 51     	nextreg     MMU1_2000_NR_51, a  ; set 0 - $1fff
 16+  8135 3C           	inc         a
 17+  8136
 18+  8136 21 00 00     	ld          hl, 0
 19+  8139 11 01 00     	ld          de, 1
 20+  813C              .colour:
 21+  813C 36 14        	ld          (hl), 20            ; smc from above
 22+  813E 01 FF 3F     	ld          bc, $3fff
 23+  8141 ED B0        	ldir
 24+  8143 C1           	pop         bc
 25+  8144 10 E7        	djnz        .L2loop
 26+  8146
 27+  8146              	; restore ROMS
 28+  8146
 29+  8146 ED 91 50 FF  	nextreg     MMU0_0000_NR_50, $ff
 30+  814A ED 91 51 FF  	nextreg     MMU1_2000_NR_51, $ff
 31+  814E
 32+  814E              	; clear ULA
 33+  814E 21 00 40     	ld          hl, 16384
 34+  8151 11 01 40     	ld          de, 16385
 35+  8154 01 00 1B     	ld          bc, 6912
 36+  8157 36 00        	ld          (hl), 0
 37+  8159 ED B0        	ldir
 38+  815B
 39+  815B C9           	ret
 40+  815C
 41+  815C
 42+  815C              draw_map:
 43+  815C
 44+  815C              	; draws nn tiles from x,y to fille the screen
 45+  815C              	; IN IX > map to draw
 46+  815C              	; IN IY > width x height
 47+  815C
 48+  815C 3E 00        	ld          a, 0            ; black
 49+  815E CD 22 81     	call        clsL2           ; clear L2
 50+  8161
 51+  8161 FD 54        	ld 			d, iyh 			; width
 52+  8163 FD 5D        	ld 			e, iyl			; height
 53+  8165 ED 30        	mul 		d, e
 54+  8167 42           	ld 			b, d
 55+  8168 4B           	ld 			c, e 			; number of tiles to draw
 56+  8169
 57+  8169 11 00 00     	ld          de,$00'00           ; d = x  e = y
 58+  816C
 59+  816C
 60+  816C              .maploop:       ; lets draw 768 tiles
 61+  816C
 62+  816C C5           	push        bc              ; save tile counter
 63+  816D DD 66 00     	ld          h, (ix)         ; get the tile at ix
 64+  8170 3E 1A        	ld          a, 26           ; bank
 65+  8172
 66+  8172 CD 87 81     	call        dotile_8x8
 67+  8175
 68+  8175 DD 23        	inc         ix              ; move to next tile
 69+  8177 14           	inc         d               ; X + 1
 70+  8178 7A           	ld          a, d
 71+  8179 FD BC        	cp          iyh              ; is X = width?
 72+  817B
 73+  817B 20 03        	jr          nz, .no_inc_e   ; no, then skip to .no_inc_e
 74+  817D
 75+  817D 1C           	inc         e               ; X=32 so make Y+1
 76+  817E 16 00        	ld          d, 0            ; X = 0
 77+  8180
 78+  8180              .no_inc_e:
 79+  8180
 80+  8180 C1           	pop         bc              ; bring back tile counter
 81+  8181 0B           	dec         bc
 82+  8182 78           	ld          a, b
 83+  8183 B1           	or          c
 84+  8184 20 E6        	jr          nz,.maploop
 85+  8186
 86+  8186 C9           	ret
 87+  8187
 88+  8187
 89+  8187              dotile_8x8:
 90+  8187
 91+  8187              	; a > bank
 92+  8187              	; h > tile
 93+  8187              	; de > xy
 94+  8187
 95+  8187
 96+  8187              	; Draws a tile h from bank a. de = x y .Total tile size can be 16kb
 97+  8187              	; required bank is auto paged into $0000-$3FFF
 98+  8187              	; 256x192 L2 8x8 256 colour tile
 99+  8187
100+  8187 D5           	push        de                                                              ; save XY
101+  8188 CB 7C        	bit         7,h			; 8 t 		                                        ; is the tile >=128?
102+  818A 28 01        	jr          z,.noinc	 	; 12 / 7t 	20                                  ; no then jump forward
103+  818C 3C           	inc         a 			; 4 		24                                      ; yes increase base bank to 8192-16384
104+  818D
105+  818D              .noinc:
106+  818D
107+  818D ED 92 50     	nextreg     MMU0_0000_NR_50, a                                              ; set 0 - $1fff ,a 		; set correct bank
108+  8190
109+  8190              	; Grab tile, x, y
110+  8190 7C           	ld          a,h			        ; tile
111+  8191 6A           	ld          l,d			        ; x
112+  8192 63           	ld          h,e			        ; y
113+  8193
114+  8193 E6 7F        	and         127                 ; we need to wrap over 127 as we have adjusted the base bank
115+  8195
116+  8195              	; modified from the original dotile8x8 by Michael "Flash" Ware
117+  8195
118+  8195 16 40        	ld          d,64                ; find offset in data, each tile is 8x8 = 64, so multiply 64*tilenumber
119+  8197 5F           	ld          e,a					; 11
120+  8198 ED 30        	mul         d,e                 ; de holds offset
121+  819A
122+  819A 3E 00        	ld          a,%00000000			; tiles at $0
123+  819C B2           	or          d		 			; or MSB of offset
124+  819D EB           	ex          de,hl				; swap offset with xy
125+  819E 67           	ld          h,a					;
126+  819F 7B           	ld          a,e
127+  81A0 07           	rlca
128+  81A1 07           	rlca
129+  81A2 07           	rlca
130+  81A3 5F           	ld          e,a					; 4+4+4+4+4 = 20	; mul x,8
131+  81A4 7A           	ld          a,d
132+  81A5 07           	rlca
133+  81A6 07           	rlca
134+  81A7 07           	rlca
135+  81A8 57           	ld          d,a					; 4+4+4+4+4 = 20	; mul y,8
136+  81A9 E6 C0        	and         192
137+  81AB F6 03        	or          3						; or 3 to keep layer on				; 8
138+  81AD 01 3B 12     	ld          bc,LAYER2_ACCESS_P_123B
139+  81B0 ED 79        	out         (c),a      			; 21			; select bank
140+  81B2
141+  81B2 7A           	ld          a,d
142+  81B3 E6 3F        	and         63
143+  81B5 57           	ld          d,a					; clear top bits of y (dest) (4+4+4 = 12)
144+  81B6              	; T96 here
145+  81B6 3E 08        	ld          a,8					; 7
146+  81B8              .plotTilesLoop2:
147+  81B8 D5           	push        de					; 11
148+  81B9 ED A0        	ldi
149+  81BB ED A0        	ldi
150+  81BD ED A0        	ldi
151+  81BF ED A0        	ldi
152+  81C1 ED A0        	ldi
153+  81C3 ED A0        	ldi
154+  81C5 ED A0        	ldi
155+  81C7 ED A0        	ldi		    ; 8 * 16 = 128
156+  81C9
157+  81C9 D1           	pop         de					; 11
158+  81CA 14           	inc         d					; 4 add 256 for next line down
159+  81CB 3D           	dec         a					; 4
160+  81CC 20 EA        	jr          nz,.plotTilesLoop2			; 12/7
161+  81CE
162+  81CE
163+  81CE 3E 02        	ld          a,2                 ; writes off, L2 enable
164+  81D0 01 3B 12     	ld          bc,LAYER2_ACCESS_P_123B
165+  81D3 ED 79        	out         (c),a               ; 21			; select bank
166+  81D5 D1           	pop         de                  ; restore xy
167+  81D6
168+  81D6 C9           	ret
169+  81D7
170+  81D7
171+  81D7
172+  81D7              hide_ula:
173+  81D7
174+  81D7              	; clips ULA to 0,0
175+  81D7
176+  81D7 ED 91 1A 00  	nextreg     CLIP_ULA_LORES_NR_1A, 0
177+  81DB ED 91 1A 00  	nextreg     CLIP_ULA_LORES_NR_1A, 0
178+  81DF ED 91 1A 00  	nextreg     CLIP_ULA_LORES_NR_1A, 0
179+  81E3 ED 91 1A 00  	nextreg     CLIP_ULA_LORES_NR_1A, 0
180+  81E7 C9           	ret
# file closed: src/layer2.asm
 55   81E8
 56   81E8              testmap:
 57   81E8                      incbin "../assets/testmap.nxm"
 58   84E8
 59   84E8
 60   84E8              ;------------------------------------------------------------------------------
 61   84E8              ; Memory banks
 62   84E8
 63   84E8                      mmu 7   n, 26
 64   84E8                      org     $e000
 65   E000                      incbin  "../assets/testmap.nxt"                 ; L2 software tiles
 66   E500
 67   E500
 68   E500              ;------------------------------------------------------------------------------
 69   E500              ; Output configuration
 70   E500                      SAVENEX OPEN "L2_on_SLOT01.nex", main, stack_top
 71   E500                      SAVENEX CORE 3,0,0
 72   E500                      SAVENEX CFG 7,0,0,0
 73   E500                      SAVENEX AUTO
 74   E500                      SAVENEX CLOSE
# file closed: src/main.asm
